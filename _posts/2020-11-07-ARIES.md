# ARIES: A Transactional Recovery Method Supporting Find-Granulairty Locking and Partial Rollbacks Using Write-Ahead Logging

주의: 이것은 [이 문서](https://web.stanford.edu/class/cs345d-01/rl/aries.pdf) 의 한국어 번역한 것을 위주로 작성되었으며, 학습 용도로 제작되었기 떄문에 내용이 다소 부정확할 수 있습니다.

## 1. INTRODUCTION

이 섹션에서는 복원, 동시성 제어, 버퍼 관리, 및 나머지 내용들에 대한 개요들에 대해 설명한다.

### 1.1 Logging, Failures, and Recovery Methods

오늘날 잘 알려진 트랙젝션의 개념은 주변에서 오랫동안 널리 쓰여져왔다. 이것은 `ACID`(Atomicity, Consistency, Isolation, Durability)(원자성, 동시성, 독립성, 내구성)의 특성들을 내포하고 있다. 트랜젝션의 개념에 대한 적용은 데이티베이스 분야에만 국한되지 않는다. 여러 트랜젝션들의 동시 실행과 실패들을 직면하는 상황에서, 트랜젝션의 원자성과 내구성을 보장하는 것은 트랜젝션 처리에서 굉장히 중요한 부분이다. 이 문제를 해결하기 위한 많은 방법들이 여지껏 개발되어 왔지만, 그 가정들과 성능 특성들, 복잡도, 난해함들은 수용하기 어렵다. 이러한 문제들을 제대로 해결했는지 판별하기 위한 수치적 지표들로는 다음의 것들이 있을 수 있다: 얼마나 많은 것들이 동시에 한 페이지에서, 혹은 여러 페이지에 걸쳐 수행될 수 있는지, 로직의 복잡도, 공간의 효율성, 재시작에 얼마나 많은 I/O가 소모되는지, 얼마나 많은 기능들을 지원할 수 있는지, 재시작 도중에 얼마나 많은 작업들이 수행될 수 있는지, 교착상태로 인한 트랜젝션 롤백이 얼마나 자주 일어나는지, 저장될 데이터에 얼마나 다양한 제약조건이 걸리게 되는지(Unique Key를 항상 가져야 한다던지, 오브젝트의 최대 크기가 제한되어있다던지), 동시 실행을 지원하기 위해 새로운 락 모드를 지원하는지 등등.

트랜젝션과 데이터 복구를 가능하게 하기 위해, ARIES는 로그에 트랜젝션의 진척도와, 복구가능한 데이터 객체들의 변화를 일으키는 행동들을 모두 적어놓는다. 적어놓은 로그들은 데이터베이스에서 어떠한 실패가 일어나거나, 아직 커밋되지 않은 트랜젝션이 끝나지 않았을 때, 적어도 커밋된 트랜젝션들은 데이터베이스에 반영되어있음을 보장할 수 있는 증거가 된다. 로그에 적힌 행동들이 실제로 반영되고 나면, 이 로그들은 그 행동들을 재구성하여 손상된 부분을 복구하는 것의 원천이 된다. 개념적으로, 로그는 영원히 자라는 순차적인 정보로 생각될 수 있지만, 실제로 구현될 때는, 여러 개의 물리적 파일들이 순차적인 번호를 부여받아 로그를 기록하는 것을 쉽게 해준다. 모든 로그들은 로그 파일에 쓰여지면서 고유의 Log Sequence Number (`LSN`)을 부여받는다. 이 `LSN` 은 오름차순으로 부여받는다. 형식적으로, 이것들은 해당되는 로그 기록들의 논리적 주소라고 볼 수 있다. 때때로, 버전 번호나 타임스탬프등이 또한 `LSN` 으로 사용되기도 한다. 만약 한 개 이상의 로그들이 서로 다른 데이터조각과 관련된 로그 레코드들을 저장하기 위해 사용된다면, `two-phase commit protocol`의 형식이 반드시 사용되어야 한다.

비활성 버전의 로그들은 일반적으로 `stable storage` 라고 불리는 곳에 저장된다. `stable storage` 는 시스템이 갑자기 종료되었을 때도 날아가지 않고 이용가능한 저장공간을 말한다. 디스크가 비휘발성 저장공간의 한 예시이며, 이것의 안정성은 일반적으로 동시에 2개의 복사본에 로그를 동시에 저장하는 것으로 향상될 수 있다. 저장 장치에 직접 접근하여 그때 그때 저장된 로그 기록들은 주기적으로 테이프 같이 더 싸고 느린 매체에 저장(백업)되어야 한다. 저장된 로그들은 일단 데이터베이스의 적절한 이미지 복사본이 생성되고 나면 버려져도 상관없으며, 그 로그 기록들은 더 이상 복원에 사용될 필요가 없다.

로그 기록이 쓰여질 때 마다, 그것들은 일단 휘발성 메모리 공간의 버퍼에 쓰여진다. 그러다 특정 타이밍에만 로그 페이지 순서로 기록된 특정 지점까지의 로그 레코드가 `stable storage` 에 저장된다. 이것을 특정 `LSN` 까지의 로그들을 `forcing` 한다고 표현한다. 게다가 트랜젝션이나 버퍼 매니저의 활동에 의해 `forcing`이 진행되기도 하며, 프로세스가 백그라운드에서 주기적으로 로그가 찰 때 마다 `forcing` 을 진행할 수 있다.

설명을 쉽게하기 위해, 우리는 각각의 로그 레코드가 하나의 페이지에서의 업데이트만 서술한다고 가정하자. 이것은 ARIES의 필수조건은 아니다. 사실, [Starbust](#) 의 ARIES 구현에서, 가끔은 하나의 로그 레코드가 두 개의 페이지를 업데이트하는 내용을 담기도 한다. 로그 레코드의 `undo` 부분은 어떻게 트랜젝션에 의한 변화를 복원할 수 있는지에 대한 정보를 제공한다. `undo` 와 `redo` 둘 모두의 정ㅂ조를 담고 있는 로그 레코드는 `undo-redo record` 라고 불린다. 가끔은, 로그 레코드는 오직 `redo` 만을 위해, 혹은 `undo` 만을 위해 쓰여질 수도 있다. 이런 레코드들은 `redo-only record` , `undo-only record` 라고 불린다. 수행되는 행동에 따라서, 이 `undo-redo` 정보들은 물리적(업데이트 전, 혹은 오브젝트에서 특정 필드나 이미지를 업데이트 후), 혹은 수행적(Operationally)으로(add 5 to field 3 of record 15, subtract 3 from field 4 of record 10) 기록될 수도 있다. 작업 로깅(Operation loggin)은 데이터에 수행되는 작업의 의미를 이용하여 고-동시성 락 모드들을 사용할 수 있도록 해준다. 예를 들어, 어떤 작업에 대해서, 한 레코드의 특정 필드가 여러 트랜젝션들의 커밋되지 않은 업데이트를 가질 수 있다. 이것은 업데이트되는 오브젝트는 항상 락 되어야한다고 말하는 `strict excutions` 특성보다 더 큰 동시성을 부여해줄 수 있다.

`WAL` 프로토콜은 어떤 데이터를 바꾸는 것을 표현하는 로그 레코드들은 반드시 비휘발성 메모리에서 기존의 데이터를 교체해버리기 전에 `stable storage` 에 저장되어 있어야 함을 주장한다. 즉, 시스템은 페이지를 어떻게 업데이트하는지의 정보를 담은 로그 레코드의 `undo-portion` 이 `stable storage` 에 저장되기 전까지는 업데이트된 페이지를 데이터 베이스의 비휘발성 저장소 버전에 적을 수 없다는 것이다. 이 프로토콜을 강제하기 위해서, `WAL` 복구 방법을 사용하는 시스템들은 모든 페이지에서 해당 페이지에서 수행된 가장 최근의 업데이트를 설명하는 로그 레코드의 `LSN` 을 저장합니다.

작성중... 힘들어...